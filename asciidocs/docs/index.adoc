= SmallRye Health in Quarkus
ifndef::imagesdir[:imagesdir: images]
:icons: font
:experimental:
:sectnums:
:toc:
:toclevels: 5
:experimental:

== Einführung

=== Was ist Health Monitoring?
[quote]
Unter Health Monitoring versteht man den Prozess der Überprüfung des Zustands einer Anwendung,
um sicherzustellen, dass sie ordnungsgemäß und zuverlässig funktioniert.
Dabei wird die Fähigkeit der Anwendung verfolgt, zu starten, auszuführen und Datenverkehr effektiv zu verarbeiten.
Die Health Monitoring ist ein Eckpfeiler des modernen Anwendungsmanagements,
insbesondere in verteilten und Cloud-nativen Umgebungen.

=== Warum ist Health Monitoring wichtig?
* *Reliability* (Zuverlässigkeit): Erkennt Probleme frühzeitig, um Ausfallzeiten zu verhindern.
* *Scalability* (Skalierbarkeit): Stellt sicher, dass Systeme skaliert werden können, ohne dass kritische Komponenten beschädigt werden.
* *Integration*: Funktioniert mit Tools wie Kubernetes, um die Wiederherstellung zu automatisieren und die Ressourcennutzung zu verbessern. -> *Probes*

=== Eclipse MicroProfile Health
* Spezifikation im MicroProfile-Ökosystem, bietet standardisierte Möglichkeit zur Implementierung von Health-Checks

=== SmallRye Health
* konkrete Implementierung der Eclipse MicroProfile Health API
* von Quarkus verwendet

== Praxisbeispiel: SmallRye Health in Quarkus für Probes in Kubernetes

=== Standard Health Checks ausprobieren

==== Maven-Projekt erstellen

[%collapsible]
====
[source, bash]
----
mvn io.quarkus.platform:quarkus-maven-plugin:3.18.1:create \
    -DprojectGroupId==at.htlleonding \
    -DprojectArtifactId==microprofile-health-demo \
    -Dextensions=='smallrye-health' \
    -DnoCode
cd microprofile-health-demo
----
====

==== Oder Extension zu bestehendem Projekt hinzufügen

[%collapsible]
====
.Maven-Wrapper
[source, bash]
----
./mvnw quarkus:add-extension -Dextensions=='smallrye-health'
----

oder

.pom.xml
[source, xml]
----
<dependency>
    <groupId>io.quarkus</groupId>
    <artifactId>quarkus-smallrye-health</artifactId>
</dependency>
----
====

==== Maven-Projekt starten

[source, bash]
----
./mvnw clean quarkus:dev
----

==== Standard-Endpoints

Der Import der `smallrye-health` Extension stellt direkt 3 REST-Endpunkte bereit:

===== Liveness (Live)
* `GET /q/health/live`
* Zeigt an, dass die Anwendung ausgeführt wird und kein kritischer Fehler aufgetreten ist, der einen Neustart erforderlich macht.
* Falls die JVM oder der Container abstürzt oder sich in einem fehlerhaften Zustand befindet, schlägt der Liveness-Check fehl.

===== Readiness (Ready)
* `GET /q/health/ready`
* Zeigt an, dass die Anwendung zur Bearbeitung von Anfragen bereit und voll funktionsfähig ist.
* Falls Quarkus eine Abhängigkeit erkennt (z. B. Datenbank oder externe API), kann es automatisch bestimmen, dass die Anwendung nicht bereit ist, falls diese Abhängigkeit nicht verfügbar ist.

===== Started
* `GET /q/health/started`
* Zeigt an, ob der vollständige Startprozess abgeschlossen ist.
* Dies geschieht, nachdem alle Startup-Beans und StartupEvent-Listener vollständig ausgeführt wurden.

TIP: Mit `GET /q/health` werden alle Health-Checks angezeigt. Du kannst diese Endpoints nun ausprobieren.

Anzeige aller Checks:
[%collapsible]
====

.`/q/health`
[source, json]
----
{
    "status": "UP", <1>
    "checks": [ <2>
        {
            "name": "alive",
            "status": "UP"
        }
    ]
}
----

.`/q/health/live`
[source, json]
----
{
    "status": "UP", <1>
    "checks": [ <2>
        {
            "name": "alive",
            "status": "UP"
        }
    ]
}
----

.`/q/health/ready`
[source, json]
----
{
    "status": "UP", <1>
    "checks": [ <2>
    ]
}
----

.`/q/health/started`
[source, json]
----
{
    "status": "UP", <1>
    "checks": [ <2>
    ]
}
----
1. `status` gibt an, ob alle Health-Checks erfolgreich waren.
2. `checks` ist ein Array von individuellen Health-Checks (dazu später mehr).

====

=== Automatischer Health-Check für JDBC-Verbindungen

NOTE: Wenn wir zu unserem Projekt eine JDBC-Datasource hinzufügen, wird automatisch ein Health Check (Readiness) erstellt, der die Verbindung zur Datenbank prüft. Hier wird dies mit einer PostgreSQL-DB demonstriert.

Siehe auch: link:quarkus-add-jdbc-postgres-source.adoc[Quarkus: JDBC Datasource hinzufügen - mit PostgreSQL als Beispiel]

*Bei den Readiness-Checks ist nun auch sichtbar, ob die Datenbank-Verbindung aufrecht ist:*

[%collapsible]
====
.`/q/health/ready`
[source, json]
----
{
    "status": "UP",
    "checks": [
        {
            "name": "Database connections health check",
            "status": "UP",
            "data": {
                "<default>": "UP"
            }
        }
    ]
}
----
====

*Stoppe nun die Datenbank und sieh dir die Readiness-Checks erneut an:*

[%collapsible]
====
.`/q/health/ready`
[source, json]
----
{
    "status": "DOWN",
    "checks": [
        {
            "name": "Database connections health check",
            "status": "DOWN",
            "data": {
                "<default>": "Unable to execute the validation check for the default DataSource: Connection to localhost:5432 refused. Check that the hostname and port are correct and that the postmaster is accepting TCP/IP connections."
            }
        }
    ]
}
----
====

=== Eigene Health-Checks erstellen



== Quellen und Links
* https://quarkus.io/guides/smallrye-health[quarkus.io: SmallRye Health]
* https://github.com/smallrye/smallrye-health[GitHub: SmallRye Health]
* https://github.com/eclipse/microprofile-health/[GitHub: Eclipse MicroProfile Health]
